#################################
#             Corners           #
#################################
# requires: https://github.com/sdhand/compton
corner-radius = 10.0;
rounded-corners-exclude = [
# "window_type = 'normal'",
#  "class_g = 'Alacritty'",
#  "class_g = 'Polybar'",
  "class_g = 'code-oss'",
  "class_g = 'firefox'"
];
round-borders = 10;
round-borders-exclude = [
  "class_g ?= 'tray'"
];

# Specify a list of border width rules, in the format `PIXELS:PATTERN`, 
# Note we don't make any guarantee about possible conflicts with the
# border_width set by the window manager.
#
# example:
#    round-borders-rule = [ "2:class_g = 'URxvt'" ];
#
round-borders-rule = [
  "15:class_g     = 'Alacritty'",
  "15:class_g     = 'Polybar'"
];

#################################
#             Shadows           #
#################################


shadow = false;
shadow-radius = 7;
shadow-opacity = .75;
shadow-offset-x = -7;
shadow-offset-y = -7;
shadow-color = "#000000";

shadow-exclude = [
  "name = 'Notification'",
  "class_g = 'Conky'",
  "class_g ?= 'Notify-osd'",
  "class_g = 'Cairo-clock'",
  "class_g = 'slop'",
  "class_g = 'xob'",
  "class_g = 'Polybar'",
  "class_g = 'Dunst'",
  "window_type = 'tooltip'",
  "_GTK_FRAME_EXTENTS@:c"
];


#################################
#           Fading              #
#################################

fading = true;
fade-in-step = 0.03;
fade-out-step = 0.03;

fade-delta = 10

fade-exclude = [
  "class_g = 'slop'",
  "class_g = 'xob'",
  "class_g = 'Polybar'",
  "window_type = 'tooltip'",
  "class_g = 'Dunst'",
  "class_g = 'slop'"   # maim
];

no-fading-destroyed-argb = false;


#################################
#   Transparency / Opacity      #
#################################

inactive-opacity = 0.8;
frame-opacity = 0.7;
inactive-opacity-override = false;
active-opacity = 1.0;

focus-exclude = [
  "class_g = 'Polybar'",                    # Polybar
  "class_g = 'Dunst'",
  "class_g = 'slop'",
  "class_g = 'xob'",
  "window_type = 'tooltip'"
];

opacity-rule = [
  #"100:class_g    = 'Alacritty'",
  "70:class_g     = 'Polybar'",
  "100:class_g    = 'code-oss'",
  "100:class_g    = 'firefox'",
  "100:class_g    = 'Thunderbird'"
];

#################################
#     Background-Blurring       #
#################################

blur: {
  # requires: https://github.com/ibhagwan/picom
  method = "dual_kawase";
  strength = 5;
  background = true;
  background-frame = true;
  background-fixed = true;
  kern = "3x3box";
}

blur-background-exclude = [
  #"window_type = 'dock'",
  #"window_type = 'desktop'",
  "class_g = 'slop'",
  "class_g = 'xob'",
  "class_g = 'Polybar'",
  "class_g = 'Dunst'",
  "window_type = 'tooltip'"
];

#################################
#       General Settings        #
#################################

# Daemonize process. Fork to background after initialization. Causes issues with certain (badly-written) drivers.
# daemon = false

# Specify the backend to use: `xrender`, `glx`, or `xr_glx_hybrid`.
# `xrender` i the default one.
#
experimental-backends = true;
backend = "glx";
#backend = "xrender";
vsync = true;
mark-wmwin-focused = false;
mark-ovredir-focused = false;
detect-rounded-corners = false;
detect-client-opacity = false;
refresh-rate = 0;

# Use EWMH '_NET_ACTIVE_WINDOW' to determine currently focused window,
# rather than listening to 'FocusIn'/'FocusOut' event. Might have more accuracy,
# provided that the WM supports it.
#
# use-ewmh-active-win = false

# Unredirect all windows if a full-screen opaque window is detected,
# to maximize performance for full-screen windows. Known to cause flickering
# when redirecting/unredirecting windows.
#
# unredir-if-possible = false

# Delay before unredirecting the window, in milliseconds. Defaults to 0.
# unredir-if-possible-delay = 0

detect-transient = false;
detect-client-leader = false;

# Resize damaged region by a specific number of pixels.
# A positive value enlarges it while a negative one shrinks it.
# If the value is positive, those additional pixels will not be actually painted
# to screen, only used in blur calculation, and such. (Due to technical limitations,
# with use-damage, those pixels will still be incorrectly painted to screen.)
# Primarily used to fix the line corruption issues of blur,
# in which case you should use the blur radius value here
# (e.g. with a 3x3 kernel, you should use `--resize-damage 1`,
# with a 5x5 one you use `--resize-damage 2`, and so on).
# May or may not work with *--glx-no-stencil*. Shrinking doesn't function correctly.
#
# resize-damage = 1

# Specify a list of conditions of windows that should be painted with inverted color.
# Resource-hogging, and is not well tested.
#
# invert-color-include = []

# GLX backend: Avoid using stencil buffer, useful if you don't have a stencil buffer.
# Might cause incorrect opacity when rendering transparent content (but never
# practically happened) and may not work with blur-background.
# My tests show a 15% performance boost. Recommended.
#
# glx-no-stencil = false

# GLX backend: Avoid rebinding pixmap on window damage.
# Probably could improve performance on rapid window content changes,
# but is known to break things on some drivers (LLVMpipe, xf86-video-intel, etc.).
# Recommended if it works.
#
# glx-no-rebind-pixmap = false

# Disable the use of damage information.
# This cause the whole screen to be redrawn everytime, instead of the part of the screen
# has actually changed. Potentially degrades the performance, but might fix some artifacts.
# The opposing option is use-damage
#
# no-use-damage = false
use-damage = true;

# Use X Sync fence to sync clients' draw calls, to make sure all draw
# calls are finished before picom starts drawing. Needed on nvidia-drivers
# with GLX backend for some users.
#
# xrender-sync-fence = false

# GLX backend: Use specified GLSL fragment shader for rendering window contents.
# See `compton-default-fshader-win.glsl` and `compton-fake-transparency-fshader-win.glsl`
# in the source tree for examples.
#
# glx-fshader-win = ""

# Force all windows to be painted with blending. Useful if you
# have a glx-fshader-win that could turn opaque pixels transparent.
#
# force-win-blend = false

# Do not use EWMH to detect fullscreen windows.
# Reverts to checking if a window is fullscreen based only on its size and coordinates.
#
# no-ewmh-fullscreen = false

# Dimming bright windows so their brightness doesn't exceed this set value.
# Brightness of a window is estimated by averaging all pixels in the window,
# so this could comes with a performance hit.
# Setting this to 1.0 disables this behaviour. Requires --use-damage to be disabled. (default: 1.0)
#
# max-brightness = 1.0

# Make transparent windows clip other windows like non-transparent windows do,
# instead of blending on top of them.
#
# transparent-clipping = false
log-level = "info";

wintypes:
{
  normal = { fade = false; shadow = false; }
  tooltip = { fade = true; shadow = true; opacity = 0.75; focus = true; full-shadow = false; };
  dock = { shadow = false; }
  dnd = { shadow = false; }
  popup_menu = { opacity = 0.8; }
  dropdown_menu = { opacity = 0.8; }
};
